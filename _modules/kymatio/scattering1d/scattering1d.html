
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>kymatio.scattering1d.scattering1d &#8212; kymatio 0.1.0-dev documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/gallery.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/kymatio.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
    <link rel="apple-touch-icon" href="../../../_static/kymatio.jpg" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for kymatio.scattering1d.scattering1d</h1><div class="highlight"><pre>
<span></span><span class="c1"># Authors: Mathieu Andreux, Joakim Andén, Edouard Oyallon</span>
<span class="c1"># Scientific Ancestry: Joakim Andén, Mathieu Andreux, Vincent Lostanlen</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">.backend</span> <span class="k">import</span> <span class="p">(</span><span class="n">fft1d_c2c</span><span class="p">,</span> <span class="n">ifft1d_c2c</span><span class="p">,</span> <span class="n">modulus_complex</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span>
    <span class="n">subsample_fourier</span><span class="p">,</span> <span class="n">unpad</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.filter_bank</span> <span class="k">import</span> <span class="p">(</span><span class="n">calibrate_scattering_filters</span><span class="p">,</span>
    <span class="n">scattering_filter_factory</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">cast_phi</span><span class="p">,</span> <span class="n">cast_psi</span><span class="p">,</span> <span class="n">compute_border_indices</span><span class="p">,</span> <span class="n">compute_padding</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Scattering1D&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Scattering1D"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D">[docs]</a><span class="k">class</span> <span class="nc">Scattering1D</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The 1D scattering transform</span>

<span class="sd">    The scattering transform computes a cascade of wavelet transforms</span>
<span class="sd">    alternated with a complex modulus non-linearity. The scattering transform</span>
<span class="sd">    of a 1D signal :math:`x(t)` may be written as</span>

<span class="sd">        $S_J x = [S_J^{(0)} x, S_J^{(1)} x, S_J^{(2)} x]$</span>

<span class="sd">    where</span>

<span class="sd">        $S_J^{(0)} x(t) = x \\star \\phi_J(t)$,</span>

<span class="sd">        $S_J^{(1)} x(t, \\lambda) =|x \\star \\psi_\\lambda^{(1)}| \\star \\phi_J$, and</span>

<span class="sd">        $S_J^{(2)} x(t, \\lambda, \\mu) = |\\,| x \\star \\psi_\\lambda^{(1)}| \\star \\psi_\\mu^{(2)} | \\star \\phi_J$.</span>

<span class="sd">    In the above formulas, :math:`\\star` denotes convolution in time. The</span>
<span class="sd">    filters $\\psi_\\lambda^{(1)}(t)$ and $\\psi_\\mu^{(2)}(t)$</span>
<span class="sd">    are analytic wavelets with center frequencies $\\lambda$ and</span>
<span class="sd">    $\\mu$, while $\\phi_J(t)$ is a real lowpass filter centered</span>
<span class="sd">    at the zero frequency.</span>

<span class="sd">    The `Scattering1D` class implements the 1D scattering transform for a</span>
<span class="sd">    given set of filters whose parameters are specified at initialization.</span>
<span class="sd">    While the wavelets are fixed, other parameters may be changed after the</span>
<span class="sd">    object is created, such as whether to compute all of :math:`S_J^{(0)} x`,</span>
<span class="sd">    $S_J^{(1)} x$, and $S_J^{(2)} x$ or just $S_J^{(0)} x$</span>
<span class="sd">    and $S_J^{(1)} x$.</span>

<span class="sd">    The scattering transform may be computed on the CPU (the default) or a</span>
<span class="sd">    GPU, if available. A `Scattering1D` object may be transferred from one</span>
<span class="sd">    to the other using the `cuda()` and `cpu()` methods.</span>

<span class="sd">    Given an input Tensor `x` of size `(B, T)`, where `B` is the number of</span>
<span class="sd">    signals to transform (the batch size) and `T` is the length of the signal,</span>
<span class="sd">    we compute its scattering transform by passing it to the `forward()`</span>
<span class="sd">    method.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    ::</span>

<span class="sd">        # Set the parameters of the scattering transform.</span>
<span class="sd">        J = 6</span>
<span class="sd">        T = 2**13</span>
<span class="sd">        Q = 8</span>

<span class="sd">        # Generate a sample signal.</span>
<span class="sd">        x = torch.randn(1, 1, T)</span>

<span class="sd">        # Define a Scattering1D object.</span>
<span class="sd">        S = Scattering1D(J, T, Q)</span>

<span class="sd">        # Calculate the scattering transform.</span>
<span class="sd">        Sx = S.forward(x)</span>

<span class="sd">    Above, the length of the signal is `T = 2**13 = 8192`, while the maximum</span>
<span class="sd">    scale of the scattering transform is set to `2**J = 2**6 = 64`. The</span>
<span class="sd">    time-frequency resolution of the first-order wavelets</span>
<span class="sd">    :math:`\\psi_\\lambda^{(1)}(t)` is set to `Q = 8` wavelets per octave.</span>
<span class="sd">    The second-order wavelets :math:`\\psi_\\mu^{(2)}(t)` always have one</span>
<span class="sd">    wavelet per octave.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        The maximum log-scale of the scattering transform. In other words,</span>
<span class="sd">        the maximum scale is given by `2**J`.</span>
<span class="sd">    T : int</span>
<span class="sd">        The length of the input signals.</span>
<span class="sd">    Q : int &gt;= 1</span>
<span class="sd">        The number of first-order wavelets per octave (second-order wavelets</span>
<span class="sd">        are fixed to one wavelet per octave). Defaults to `1`.</span>
<span class="sd">    max_order : int, optional</span>
<span class="sd">        The maximum order of scattering coefficients to compute. Must be either</span>
<span class="sd">        `1` or `2`. Defaults to `2`.</span>
<span class="sd">    average : boolean, optional</span>
<span class="sd">        Determines whether the output is averaged in time or not. The averaged</span>
<span class="sd">        output corresponds to the standard scattering transform, while the</span>
<span class="sd">        un-averaged output skips the last convolution by :math:`\\phi_J(t)`.</span>
<span class="sd">        This parameter may be modified after object creation.</span>
<span class="sd">        Defaults to `True`.</span>
<span class="sd">    oversampling : integer &gt;= 0, optional</span>
<span class="sd">        Controls the oversampling factor relative to the default as a power</span>
<span class="sd">        of two. Since the convolving by wavelets (or lowpass filters) and</span>
<span class="sd">        taking the modulus reduces the high-frequency content of the signal,</span>
<span class="sd">        we can subsample to save space and improve performance. However, this</span>
<span class="sd">        may reduce precision in the calculation. If this is not desirable,</span>
<span class="sd">        `oversampling` can be set to a large value to prevent too much</span>
<span class="sd">        subsampling. This parameter may be modified after object creation.</span>
<span class="sd">        Defaults to `0`.</span>
<span class="sd">    vectorize : boolean, optional</span>
<span class="sd">        Determines wheter to return a vectorized scattering transform (that</span>
<span class="sd">        is, a large array containing the output) or a dictionary (where each</span>
<span class="sd">        entry corresponds to a separate scattering coefficient). This parameter</span>
<span class="sd">        may be modified after object creation. Defaults to True.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    J : int</span>
<span class="sd">        The maximum log-scale of the scattering transform. In other words,</span>
<span class="sd">        the maximum scale is given by `2**J`.</span>
<span class="sd">    shape : int</span>
<span class="sd">        The length of the input signals.</span>
<span class="sd">    Q : int</span>
<span class="sd">        The number of first-order wavelets per octave (second-order wavelets</span>
<span class="sd">        are fixed to one wavelet per octave).</span>
<span class="sd">    J_pad : int</span>
<span class="sd">        The logarithm of the padded length of the signals.</span>
<span class="sd">    pad_left : int</span>
<span class="sd">        The amount of padding to the left of the signal.</span>
<span class="sd">    pad_right : int</span>
<span class="sd">        The amount of padding to the right of the signal.</span>
<span class="sd">    phi_f : dictionary</span>
<span class="sd">        A dictionary containing the lowpass filter at all resolutions. See</span>
<span class="sd">        `filter_bank.scattering_filter_factory` for an exact description.</span>
<span class="sd">    psi1_f : dictionary</span>
<span class="sd">        A dictionary containing all the first-order wavelet filters, each</span>
<span class="sd">        represented as a dictionary containing that filter at all</span>
<span class="sd">        resolutions. See `filter_bank.scattering_filter_factory` for an exact</span>
<span class="sd">        description.</span>
<span class="sd">    psi2_f : dictionary</span>
<span class="sd">        A dictionary containing all the second-order wavelet filters, each</span>
<span class="sd">        represented as a dictionary containing that filter at all</span>
<span class="sd">        resolutions. See `filter_bank.scattering_filter_factory` for an exact</span>
<span class="sd">        description.</span>
<span class="sd">        description</span>
<span class="sd">    max_order : int</span>
<span class="sd">        The maximum scattering order of the transform.</span>
<span class="sd">    average : boolean</span>
<span class="sd">        Controls whether the output should be averaged (the standard</span>
<span class="sd">        scattering transform) or not (resulting in wavelet modulus</span>
<span class="sd">        coefficients). Note that to obtain unaveraged output, the `vectorize`</span>
<span class="sd">        flag must be set to `False`.</span>
<span class="sd">    oversampling : int</span>
<span class="sd">        The number of powers of two to oversample the output compared to the</span>
<span class="sd">        default subsampling rate determined from the filters.</span>
<span class="sd">    vectorize : boolean</span>
<span class="sd">        Controls whether the output should be vectorized into a single Tensor</span>
<span class="sd">        or collected into a dictionary. For more details, see the</span>
<span class="sd">        documentation for `forward()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">Q</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">oversampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Scattering1D</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="c1"># Store the parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">Q</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">=</span> <span class="n">max_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">average</span> <span class="o">=</span> <span class="n">average</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oversampling</span> <span class="o">=</span> <span class="n">oversampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vectorize</span> <span class="o">=</span> <span class="n">vectorize</span>

        <span class="c1"># Build internal values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<div class="viewcode-block" id="Scattering1D.build"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.build">[docs]</a>    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set up padding and filters</span>

<span class="sd">        Certain internal data, such as the amount of padding and the wavelet</span>
<span class="sd">        filters to be used in the scattering transform, need to be computed</span>
<span class="sd">        from the parameters given during construction. This function is called</span>
<span class="sd">        automatically during object creation and no subsequent calls are</span>
<span class="sd">        therefore needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set these default values for now. In the future, we&#39;ll want some</span>
        <span class="c1"># flexibility for these, but for now, let&#39;s keep them fixed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r_psi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">5.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">P_max</span> <span class="o">=</span> <span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-7</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">criterion_amplitude</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize</span> <span class="o">=</span> <span class="s1">&#39;l1&#39;</span>

        <span class="c1"># check the shape</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If shape is specified as a tuple, it must &quot;</span>
                                 <span class="s2">&quot;have exactly one element&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape must be an integer or a 1-tuple&quot;</span><span class="p">)</span>

        <span class="c1"># Compute the minimum support to pad (ideally)</span>
        <span class="n">min_to_pad</span> <span class="o">=</span> <span class="n">compute_minimum_support_to_pad</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">r_psi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r_psi</span><span class="p">,</span> <span class="n">sigma0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="n">P_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">P_max</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
            <span class="n">criterion_amplitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion_amplitude</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">)</span>
        <span class="c1"># to avoid padding more than T - 1 on the left and on the right,</span>
        <span class="c1"># since otherwise torch sends nans</span>
        <span class="n">J_max_support</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J_pad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_to_pad</span><span class="p">))),</span>
                         <span class="n">J_max_support</span><span class="p">)</span>
        <span class="c1"># compute the padding quantities:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span> <span class="o">=</span> <span class="n">compute_padding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J_pad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># compute start and end indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ind_start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ind_end</span> <span class="o">=</span> <span class="n">compute_border_indices</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># Finally, precompute the filters</span>
        <span class="n">phi_f</span><span class="p">,</span> <span class="n">psi1_f</span><span class="p">,</span> <span class="n">psi2_f</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">scattering_filter_factory</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J_pad</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">to_torch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">criterion_amplitude</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">criterion_amplitude</span><span class="p">,</span>
            <span class="n">r_psi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">r_psi</span><span class="p">,</span> <span class="n">sigma0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
            <span class="n">P_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">P_max</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi1_f</span> <span class="o">=</span> <span class="n">psi1_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi2_f</span> <span class="o">=</span> <span class="n">psi2_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_f</span> <span class="o">=</span> <span class="n">phi_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change the datatype of the filters</span>

<span class="sd">        This function is used internally to convert the filters. It does not</span>
<span class="sd">        need to be called explicitly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_type : type</span>
<span class="sd">            The desired type of the filters, typically `torch.FloatTensor`</span>
<span class="sd">            or `torch.cuda.FloatTensor`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cast_psi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi1_f</span><span class="p">,</span> <span class="n">target_type</span><span class="p">)</span>
        <span class="n">cast_psi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi2_f</span><span class="p">,</span> <span class="n">target_type</span><span class="p">)</span>
        <span class="n">cast_phi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phi_f</span><span class="p">,</span> <span class="n">target_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move to the CPU</span>

<span class="sd">        This function prepares the object to accept input Tensors on the CPU.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cuda</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Move to the GPU</span>

<span class="sd">        This function prepares the object to accept input Tensors on the GPU.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">FloatTensor</span><span class="p">)</span>

<div class="viewcode-block" id="Scattering1D.meta"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.meta">[docs]</a>    <span class="k">def</span> <span class="nf">meta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get meta information on the transform</span>

<span class="sd">        Calls the static method `compute_meta_scattering()` with the</span>
<span class="sd">        parameters of the transform object.</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        meta : dictionary</span>
<span class="sd">            See the documentation for `compute_meta_scattering()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Scattering1D</span><span class="o">.</span><span class="n">compute_meta_scattering</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scattering1D.output_size"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.output_size">[docs]</a>    <span class="k">def</span> <span class="nf">output_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get size of the scattering transform</span>

<span class="sd">        Calls the static method `precompute_size_scattering()` with the</span>
<span class="sd">        parameters of the transform object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detail : boolean, optional</span>
<span class="sd">            Specifies whether to provide a detailed size (number of coefficient</span>
<span class="sd">            per order) or an aggregate size (total number of coefficients).</span>

<span class="sd">        Returns</span>
<span class="sd">        ------</span>
<span class="sd">        size : int or tuple</span>
<span class="sd">            See the documentation for `precompute_size_scattering()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Scattering1D</span><span class="o">.</span><span class="n">precompute_size_scattering</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="n">detail</span><span class="p">)</span></div>

<div class="viewcode-block" id="Scattering1D.forward"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Apply the scattering transform</span>

<span class="sd">        Given an input Tensor of size `(B, T0)`, where `B` is the batch</span>
<span class="sd">        size and `T0` is the length of the individual signals, this function</span>
<span class="sd">        computes its scattering transform. If the `vectorize` flag is set to</span>
<span class="sd">        `True`, the output is in the form of a Tensor or size `(B, C, T1)`,</span>
<span class="sd">        where `T1` is the signal length after subsampling to the scale `2**J`</span>
<span class="sd">        (with the appropriate oversampling factor to reduce aliasing), and</span>
<span class="sd">        `C` is the number of scattering coefficients.  If `vectorize` is set</span>
<span class="sd">        `False`, however, the output is a dictionary containing `C` keys, each</span>
<span class="sd">        a tuple whose length corresponds to the scattering order and whose</span>
<span class="sd">        elements are the sequence of filter indices used.</span>

<span class="sd">        Furthermore, if the `average` flag is set to `False`, these outputs</span>
<span class="sd">        are not averaged, but are simply the wavelet modulus coefficients of</span>
<span class="sd">        the filters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : tensor</span>
<span class="sd">            An input Tensor of size `(B, T0)`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        S : tensor or dictionary</span>
<span class="sd">            If the `vectorize` flag is `True`, the output is a Tensor</span>
<span class="sd">            containing the scattering coefficients, while if `vectorize`</span>
<span class="sd">            is `False`, it is a dictionary indexed by tuples of filter indices.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># basic checking, should be improved</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Input tensor x should have at least one axis, got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>

        <span class="n">batch_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">signal_shape</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">signal_shape</span><span class="p">)</span>

        <span class="c1"># get the arguments before calling the scattering</span>
        <span class="c1"># treat the arguments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorize</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Options average=False and vectorize=True are &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;mutually incompatible. Please set vectorize to False.&#39;</span><span class="p">)</span>
            <span class="n">size_scattering</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">precompute_size_scattering</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size_scattering</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi1_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi2_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phi_f</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">,</span>
                       <span class="n">pad_left</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_left</span><span class="p">,</span> <span class="n">pad_right</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pad_right</span><span class="p">,</span>
                       <span class="n">ind_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ind_start</span><span class="p">,</span> <span class="n">ind_end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ind_end</span><span class="p">,</span>
                       <span class="n">oversampling</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">oversampling</span><span class="p">,</span>
                       <span class="n">vectorize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">vectorize</span><span class="p">,</span>
                       <span class="n">size_scattering</span><span class="o">=</span><span class="n">size_scattering</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vectorize</span><span class="p">:</span>
            <span class="n">scattering_shape</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="n">scattering_shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">scattering_shape</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
                <span class="n">S</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">batch_shape</span> <span class="o">+</span> <span class="n">scattering_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span></div>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="Scattering1D.compute_meta_scattering"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.compute_meta_scattering">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_meta_scattering</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get metadata on the transform.</span>

<span class="sd">        This information specifies the content of each scattering coefficient,</span>
<span class="sd">        which order, which frequencies, which filters were used, and so on.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        J : int</span>
<span class="sd">            The maximum log-scale of the scattering transform.</span>
<span class="sd">            In other words, the maximum scale is given by `2**J`.</span>
<span class="sd">        Q : int &gt;= 1</span>
<span class="sd">            The number of first-order wavelets per octave.</span>
<span class="sd">            Second-order wavelets are fixed to one wavelet per octave.</span>
<span class="sd">        max_order : int, optional</span>
<span class="sd">            The maximum order of scattering coefficients to compute.</span>
<span class="sd">            Must be either equal to `1` or `2`. Defaults to `2`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        meta : dictionary</span>
<span class="sd">            A dictionary with the following keys:</span>

<span class="sd">            - `&#39;order`&#39; : tensor</span>
<span class="sd">                A Tensor of length `C`, the total number of scattering</span>
<span class="sd">                coefficients, specifying the scattering order.</span>
<span class="sd">            - `&#39;xi&#39;` : tensor</span>
<span class="sd">                A Tensor of size `(C, max_order)`, specifying the center</span>
<span class="sd">                frequency of the filter used at each order (padded with NaNs).</span>
<span class="sd">            - `&#39;sigma&#39;` : tensor</span>
<span class="sd">                A Tensor of size `(C, max_order)`, specifying the frequency</span>
<span class="sd">                bandwidth of the filter used at each order (padded with NaNs).</span>
<span class="sd">            - `&#39;j&#39;` : tensor</span>
<span class="sd">                A Tensor of size `(C, max_order)`, specifying the dyadic scale</span>
<span class="sd">                of the filter used at each order (padded with NaNs).</span>
<span class="sd">            - `&#39;n&#39;` : tensor</span>
<span class="sd">                A Tensor of size `(C, max_order)`, specifying the indices of</span>
<span class="sd">                the filters used at each order (padded with NaNs).</span>
<span class="sd">            - `&#39;key&#39;` : list</span>
<span class="sd">                The tuples indexing the corresponding scattering coefficient</span>
<span class="sd">                in the non-vectorized output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_low</span><span class="p">,</span> <span class="n">xi1s</span><span class="p">,</span> <span class="n">sigma1s</span><span class="p">,</span> <span class="n">j1s</span><span class="p">,</span> <span class="n">xi2s</span><span class="p">,</span> <span class="n">sigma2s</span><span class="p">,</span> <span class="n">j2s</span> <span class="o">=</span> \
            <span class="n">calibrate_scattering_filters</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

        <span class="n">meta</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>

        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
        <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="p">(</span><span class="n">xi1</span><span class="p">,</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">j1</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xi1s</span><span class="p">,</span> <span class="n">sigma1s</span><span class="p">,</span> <span class="n">j1s</span><span class="p">)):</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xi1</span><span class="p">,))</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sigma1</span><span class="p">,))</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j1</span><span class="p">,))</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,))</span>
            <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,))</span>

            <span class="k">if</span> <span class="n">max_order</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="p">(</span><span class="n">xi2</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xi2s</span><span class="p">,</span> <span class="n">sigma2s</span><span class="p">,</span> <span class="n">j2s</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&gt;</span> <span class="n">j1</span><span class="p">:</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xi1</span><span class="p">,</span> <span class="n">xi2</span><span class="p">))</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">))</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">j1</span><span class="p">,</span> <span class="n">j2</span><span class="p">))</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">pad_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]</span>
        <span class="n">pad_len</span> <span class="o">=</span> <span class="n">max_order</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">pad_fields</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">pad_len</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">[</span><span class="n">field</span><span class="p">]]</span>

        <span class="n">array_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;xi&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;j&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">array_fields</span><span class="p">:</span>
            <span class="n">meta</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">from_numpy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="n">field</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">meta</span></div>

<div class="viewcode-block" id="Scattering1D.precompute_size_scattering"><a class="viewcode-back" href="../../../codereference.html#kymatio.Scattering1D.precompute_size_scattering">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">precompute_size_scattering</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">max_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get size of the scattering transform</span>

<span class="sd">        The number of scattering coefficients depends on the filter</span>
<span class="sd">        configuration and so can be calculated using a few of the scattering</span>
<span class="sd">        transform parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        J : int</span>
<span class="sd">            The maximum log-scale of the scattering transform.</span>
<span class="sd">            In other words, the maximum scale is given by `2**J`.</span>
<span class="sd">        Q : int &gt;= 1</span>
<span class="sd">            The number of first-order wavelets per octave.</span>
<span class="sd">            Second-order wavelets are fixed to one wavelet per octave.</span>
<span class="sd">        max_order : int, optional</span>
<span class="sd">            The maximum order of scattering coefficients to compute.</span>
<span class="sd">            Must be either equal to `1` or `2`. Defaults to `2`.</span>
<span class="sd">        detail : boolean, optional</span>
<span class="sd">            Specifies whether to provide a detailed size (number of coefficient</span>
<span class="sd">            per order) or an aggregate size (total number of coefficients).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        size : int or tuple</span>
<span class="sd">            If `detail` is `False`, returns the number of coefficients as an</span>
<span class="sd">            integer. If `True`, returns a tuple of size `max_order` containing</span>
<span class="sd">            the number of coefficients in each order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sigma_low</span><span class="p">,</span> <span class="n">xi1</span><span class="p">,</span> <span class="n">sigma1</span><span class="p">,</span> <span class="n">j1</span><span class="p">,</span> <span class="n">xi2</span><span class="p">,</span> <span class="n">sigma2</span><span class="p">,</span> <span class="n">j2</span> <span class="o">=</span> \
            <span class="n">calibrate_scattering_filters</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

        <span class="n">size_order0</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">size_order1</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi1</span><span class="p">)</span>
        <span class="n">size_order2</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xi2</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">j2</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">j1</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
                    <span class="n">size_order2</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">detail</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size_order0</span><span class="p">,</span> <span class="n">size_order1</span><span class="p">,</span> <span class="n">size_order2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">max_order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">size_order0</span> <span class="o">+</span> <span class="n">size_order1</span> <span class="o">+</span> <span class="n">size_order2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">size_order0</span> <span class="o">+</span> <span class="n">size_order1</span></div></div>


<span class="k">def</span> <span class="nf">compute_minimum_support_to_pad</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">criterion_amplitude</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
                                   <span class="n">normalize</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">,</span> <span class="n">r_psi</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
                                   <span class="n">sigma0</span><span class="o">=</span><span class="mf">1e-1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">5.</span><span class="p">,</span> <span class="n">P_max</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the support to pad given the input size and the parameters of the</span>
<span class="sd">    scattering transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    T : int</span>
<span class="sd">        temporal size of the input signal</span>
<span class="sd">    J : int</span>
<span class="sd">        scale of the scattering</span>
<span class="sd">    Q : int</span>
<span class="sd">        number of wavelets per octave</span>
<span class="sd">    normalize : string, optional</span>
<span class="sd">        normalization type for the wavelets.</span>
<span class="sd">        Only `&#39;l2&#39;` or `&#39;l1&#39;` normalizations are supported.</span>
<span class="sd">        Defaults to `&#39;l1&#39;`</span>
<span class="sd">    criterion_amplitude: float `&gt;0` and `&lt;1`, optional</span>
<span class="sd">        Represents the numerical error which is allowed to be lost after</span>
<span class="sd">        convolution and padding.</span>
<span class="sd">        The larger criterion_amplitude, the smaller the padding size is.</span>
<span class="sd">        Defaults to `1e-3`</span>
<span class="sd">    r_psi : float, optional</span>
<span class="sd">        Should be `&gt;0` and `&lt;1`. Controls the redundancy of the filters</span>
<span class="sd">        (the larger r_psi, the larger the overlap between adjacent</span>
<span class="sd">        wavelets).</span>
<span class="sd">        Defaults to `sqrt(0.5)`.</span>
<span class="sd">    sigma0 : float, optional</span>
<span class="sd">        parameter controlling the frequential width of the</span>
<span class="sd">        low-pass filter at J_scattering=0; at a an absolute J_scattering,</span>
<span class="sd">        it is equal to :math:`\\frac{\\sigma_0}{2^J}`.</span>
<span class="sd">        Defaults to `1e-1`.</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        tolerance factor for the aliasing after subsampling.</span>
<span class="sd">        The larger the alpha, the more conservative the value of maximal</span>
<span class="sd">        subsampling is.</span>
<span class="sd">        Defaults to `5`.</span>
<span class="sd">    P_max : int, optional</span>
<span class="sd">        maximal number of periods to use to make sure that the Fourier</span>
<span class="sd">        transform of the filters is periodic.</span>
<span class="sd">        `P_max = 5` is more than enough for double precision.</span>
<span class="sd">        Defaults to `5`.</span>
<span class="sd">    eps : float, optional</span>
<span class="sd">        required machine precision for the periodization (single</span>
<span class="sd">        floating point is enough for deep learning applications).</span>
<span class="sd">        Defaults to `1e-7`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    min_to_pad: int</span>
<span class="sd">        minimal value to pad the signal on one size to avoid any</span>
<span class="sd">        boundary error.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">J_tentative</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">T</span><span class="p">)))</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">t_max_phi</span> <span class="o">=</span> <span class="n">scattering_filter_factory</span><span class="p">(</span>
        <span class="n">J_tentative</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">Q</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">to_torch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_subsampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">criterion_amplitude</span><span class="o">=</span><span class="n">criterion_amplitude</span><span class="p">,</span>
        <span class="n">r_psi</span><span class="o">=</span><span class="n">r_psi</span><span class="p">,</span> <span class="n">sigma0</span><span class="o">=</span><span class="n">sigma0</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">P_max</span><span class="o">=</span><span class="n">P_max</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">min_to_pad</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">t_max_phi</span>
    <span class="k">return</span> <span class="n">min_to_pad</span>


<span class="k">def</span> <span class="nf">scattering</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">psi1</span><span class="p">,</span> <span class="n">psi2</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">pad_left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_right</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">ind_start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ind_end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oversampling</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">max_order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">average</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">size_scattering</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">vectorize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Main function implementing the 1-D scattering transform.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : Tensor</span>
<span class="sd">        a torch Tensor of size `(B, 1, T)` where `T` is the temporal size</span>
<span class="sd">    psi1 : dictionary</span>
<span class="sd">        a dictionary of filters (in the Fourier domain), with keys (`j`, `q`).</span>
<span class="sd">        `j` corresponds to the downsampling factor for</span>
<span class="sd">        :math:`x \\ast psi1[(j, q)]``, and `q` corresponds to a pitch class</span>
<span class="sd">        (chroma).</span>
<span class="sd">        * psi1[(j, n)] is itself a dictionary, with keys corresponding to the</span>
<span class="sd">        dilation factors: psi1[(j, n)][j2] corresponds to a support of size</span>
<span class="sd">        :math:`2^{J_\\text{max} - j_2}`, where :math:`J_\\text{max}` has been</span>
<span class="sd">        defined a priori (`J_max = size` of the padding support of the input)</span>
<span class="sd">        * psi1[(j, n)] only has real values;</span>
<span class="sd">        the tensors are complex so that broadcasting applies</span>
<span class="sd">    psi2 : dictionary</span>
<span class="sd">        a dictionary of filters, with keys (j2, n2). Same remarks as for psi1</span>
<span class="sd">    phi : dictionary</span>
<span class="sd">        a dictionary of filters of scale :math:`2^J` with keys (`j`)</span>
<span class="sd">        where :math:`2^j` is the downsampling factor.</span>
<span class="sd">        The array `phi[j]` is a real-valued filter.</span>
<span class="sd">    J : int</span>
<span class="sd">        scale of the scattering</span>
<span class="sd">    pad_left : int, optional</span>
<span class="sd">        how much to pad the signal on the left. Defaults to `0`</span>
<span class="sd">    pad_right : int, optional</span>
<span class="sd">        how much to pad the signal on the right. Defaults to `0`</span>
<span class="sd">    ind_start : dictionary of ints, optional</span>
<span class="sd">        indices to truncate the signal to recover only the</span>
<span class="sd">        parts which correspond to the actual signal after padding and</span>
<span class="sd">        downsampling. Defaults to None</span>
<span class="sd">    ind_end : dictionary of ints, optional</span>
<span class="sd">        See description of ind_start</span>
<span class="sd">    oversampling : int, optional</span>
<span class="sd">        how much to oversample the scattering (with respect to :math:`2^J`):</span>
<span class="sd">        the higher, the larger the resulting scattering</span>
<span class="sd">        tensor along time. Defaults to `0`</span>
<span class="sd">    order2 : boolean, optional</span>
<span class="sd">        Whether to compute the 2nd order or not. Defaults to `False`.</span>
<span class="sd">    average_U1 : boolean, optional</span>
<span class="sd">        whether to average the first order vector. Defaults to `True`</span>
<span class="sd">    size_scattering : tuple</span>
<span class="sd">        Contains the number of channels of the scattering, precomputed for</span>
<span class="sd">        speed-up. Defaults to `(0, 0, 0)`.</span>
<span class="sd">    vectorize : boolean, optional</span>
<span class="sd">        whether to return a dictionary or a tensor. Defaults to False.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># S is simply a dictionary if we do not perform the averaging...</span>
    <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">kJ</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">temporal_size</span> <span class="o">=</span> <span class="n">ind_end</span><span class="p">[</span><span class="n">kJ</span><span class="p">]</span> <span class="o">-</span> <span class="n">ind_start</span><span class="p">[</span><span class="n">kJ</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">size_scattering</span><span class="p">),</span> <span class="n">temporal_size</span><span class="p">)</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># pad to a dyadic size and make it complex</span>
    <span class="n">U0</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pad_left</span><span class="o">=</span><span class="n">pad_left</span><span class="p">,</span> <span class="n">pad_right</span><span class="o">=</span><span class="n">pad_right</span><span class="p">,</span> <span class="n">to_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># compute the Fourier transform</span>
    <span class="n">U0_hat</span> <span class="o">=</span> <span class="n">fft1d_c2c</span><span class="p">(</span><span class="n">U0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
        <span class="c1"># initialize the cursor</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">size_scattering</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># current coordinate</span>
        <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">cc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Get S0</span>
    <span class="n">k0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
        <span class="n">S0_J_hat</span> <span class="o">=</span> <span class="n">subsample_fourier</span><span class="p">(</span><span class="n">U0_hat</span> <span class="o">*</span> <span class="n">phi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">**</span><span class="n">k0</span><span class="p">)</span>
        <span class="n">S0_J</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">ifft1d_c2c</span><span class="p">(</span><span class="n">S0_J_hat</span><span class="p">)),</span>
                     <span class="n">ind_start</span><span class="p">[</span><span class="n">k0</span><span class="p">],</span> <span class="n">ind_end</span><span class="p">[</span><span class="n">k0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S0_J</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
        <span class="n">S</span><span class="p">[:,</span> <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S0_J</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">S0_J</span>
    <span class="c1"># First order:</span>
    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi1</span><span class="p">)):</span>
        <span class="c1"># Convolution + downsampling</span>
        <span class="n">j1</span> <span class="o">=</span> <span class="n">psi1</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;j&#39;</span><span class="p">]</span>
        <span class="n">k1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">j1</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">psi1</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;xi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">k1</span><span class="p">)</span>
        <span class="n">U1_hat</span> <span class="o">=</span> <span class="n">subsample_fourier</span><span class="p">(</span><span class="n">U0_hat</span> <span class="o">*</span> <span class="n">psi1</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">**</span><span class="n">k1</span><span class="p">)</span>
        <span class="c1"># Take the modulus</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">modulus_complex</span><span class="p">(</span><span class="n">ifft1d_c2c</span><span class="p">(</span><span class="n">U1_hat</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">average</span> <span class="ow">or</span> <span class="n">max_order</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">U1_hat</span> <span class="o">=</span> <span class="n">fft1d_c2c</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
            <span class="c1"># Convolve with phi_J</span>
            <span class="n">k1_J</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">S1_J_hat</span> <span class="o">=</span> <span class="n">subsample_fourier</span><span class="p">(</span><span class="n">U1_hat</span> <span class="o">*</span> <span class="n">phi</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="mi">2</span><span class="o">**</span><span class="n">k1_J</span><span class="p">)</span>
            <span class="n">S1_J</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">ifft1d_c2c</span><span class="p">(</span><span class="n">S1_J_hat</span><span class="p">)),</span>
                         <span class="n">ind_start</span><span class="p">[</span><span class="n">k1_J</span> <span class="o">+</span> <span class="n">k1</span><span class="p">],</span> <span class="n">ind_end</span><span class="p">[</span><span class="n">k1_J</span> <span class="o">+</span> <span class="n">k1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># just take the real value and unpad</span>
            <span class="n">S1_J</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span> <span class="n">ind_start</span><span class="p">[</span><span class="n">k1</span><span class="p">],</span> <span class="n">ind_end</span><span class="p">[</span><span class="n">k1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
            <span class="n">S</span><span class="p">[:,</span> <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S1_J</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">cc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="p">[(</span><span class="n">n1</span><span class="p">,)]</span> <span class="o">=</span> <span class="n">S1_J</span>
        <span class="k">if</span> <span class="n">max_order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># 2nd order</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">psi2</span><span class="p">)):</span>
                <span class="n">j2</span> <span class="o">=</span> <span class="n">psi2</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;j&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j2</span> <span class="o">&gt;</span> <span class="n">j1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">psi2</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="s1">&#39;xi&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">psi1</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="s1">&#39;xi&#39;</span><span class="p">]</span>
                    <span class="c1"># convolution + downsampling</span>
                    <span class="n">k2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">j2</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">U2_hat</span> <span class="o">=</span> <span class="n">subsample_fourier</span><span class="p">(</span><span class="n">U1_hat</span> <span class="o">*</span> <span class="n">psi2</span><span class="p">[</span><span class="n">n2</span><span class="p">][</span><span class="n">k1</span><span class="p">],</span>
                                               <span class="mi">2</span><span class="o">**</span><span class="n">k2</span><span class="p">)</span>
                    <span class="c1"># take the modulus and go back in Fourier</span>
                    <span class="n">U2</span> <span class="o">=</span> <span class="n">modulus_complex</span><span class="p">(</span><span class="n">ifft1d_c2c</span><span class="p">(</span><span class="n">U2_hat</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">average</span><span class="p">:</span>
                        <span class="n">U2_hat</span> <span class="o">=</span> <span class="n">fft1d_c2c</span><span class="p">(</span><span class="n">U2</span><span class="p">)</span>
                        <span class="c1"># Convolve with phi_J</span>
                        <span class="n">k2_J</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">J</span> <span class="o">-</span> <span class="n">k2</span> <span class="o">-</span> <span class="n">k1</span> <span class="o">-</span> <span class="n">oversampling</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="n">S2_J_hat</span> <span class="o">=</span> <span class="n">subsample_fourier</span><span class="p">(</span><span class="n">U2_hat</span> <span class="o">*</span> <span class="n">phi</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">],</span>
                                                     <span class="mi">2</span><span class="o">**</span><span class="n">k2_J</span><span class="p">)</span>
                        <span class="n">S2_J</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">ifft1d_c2c</span><span class="p">(</span><span class="n">S2_J_hat</span><span class="p">)),</span>
                                     <span class="n">ind_start</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">k2_J</span><span class="p">],</span>
                                     <span class="n">ind_end</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">k2_J</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># just take the real value and unpad</span>
                        <span class="n">S2_J</span> <span class="o">=</span> <span class="n">unpad</span><span class="p">(</span>
                            <span class="n">real</span><span class="p">(</span><span class="n">U2</span><span class="p">),</span> <span class="n">ind_start</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">],</span> <span class="n">ind_end</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">k2</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">vectorize</span><span class="p">:</span>
                        <span class="n">S</span><span class="p">[:,</span> <span class="n">cc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">S2_J</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">cc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">S</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">S2_J</span>

    <span class="k">return</span> <span class="n">S</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/kymatio.jpg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">Wavelet Scattering in PyTorch</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=kymatio&repo=kymatio&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/kymatio/kymatio">
    <img
        alt="https://secure.travis-ci.org/kymatio/kymatio.svg?branch=master"
        src="https://secure.travis-ci.org/kymatio/kymatio.svg?branch=master"
    />
</a>
</p>


<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../userguide.html">User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developerguide.html">Information for developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../codereference.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery_1d/index.html">1D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery_2d/index.html">2D examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery_3d/index.html">3D examples</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, The Kymatio Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    
    <a href="https://github.com/kymatio/kymatio" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-130785726-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>